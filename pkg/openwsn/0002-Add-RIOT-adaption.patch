From c2b3dc0586eec54e8c51167b6823c813b03898af Mon Sep 17 00:00:00 2001
From: Oleg Hahm <oleg@hobbykeller.org>
Date: Tue, 14 Jul 2015 18:24:20 +0200
Subject: [PATCH 02/12] Add RIOT adaption

---
 bsp/boards/riot-adaption/board_info.h |  65 +++++++++
 bsp/boards/riot-adaption/board_ow.c   |  22 +++
 bsp/boards/riot-adaption/debugpins.c  |  27 ++++
 bsp/boards/riot-adaption/eui64.c      |  25 ++++
 bsp/boards/riot-adaption/leds_ow.c    | 111 +++++++++++++++
 bsp/boards/riot-adaption/radio.c      | 259 ++++++++++++++++++++++++++++++++++
 bsp/boards/riot-adaption/radiotimer.c | 159 +++++++++++++++++++++
 bsp/boards/riot-adaption/riot.h       |  36 +++++
 bsp/boards/riot-adaption/uart_ow.c    |  96 +++++++++++++
 9 files changed, 800 insertions(+)
 create mode 100644 bsp/boards/riot-adaption/board_info.h
 create mode 100644 bsp/boards/riot-adaption/board_ow.c
 create mode 100644 bsp/boards/riot-adaption/debugpins.c
 create mode 100644 bsp/boards/riot-adaption/eui64.c
 create mode 100644 bsp/boards/riot-adaption/leds_ow.c
 create mode 100644 bsp/boards/riot-adaption/radio.c
 create mode 100644 bsp/boards/riot-adaption/radiotimer.c
 create mode 100644 bsp/boards/riot-adaption/riot.h
 create mode 100644 bsp/boards/riot-adaption/uart_ow.c

diff --git a/bsp/boards/riot-adaption/board_info.h b/bsp/boards/riot-adaption/board_info.h
new file mode 100644
index 0000000..fd46c20
--- /dev/null
+++ b/bsp/boards/riot-adaption/board_info.h
@@ -0,0 +1,65 @@
+/**
+\brief RIOT adaption information bsp module.
+
+This module simply defines some strings describing the board, which CoAP uses
+to return the board's description.
+
+\author Thomas Eichinger <thomas.eichinger@fu-berlin.de>
+*/
+
+#ifndef __BOARD_INFO_H
+#define __BOARD_INFO_H
+
+#include "stdint.h"
+#include "string.h"
+#include "cpu.h"
+
+//=========================== defines =========================================
+
+#define INTERRUPT_DECLARATION(); //no declaration
+
+#define DISABLE_INTERRUPTS()    disableIRQ();
+#define ENABLE_INTERRUPTS()     enableIRQ();
+
+//===== timer
+
+#define PORT_TIMER_WIDTH                    uint32_t
+#define PORT_RADIOTIMER_WIDTH               uint32_t
+
+#define PORT_SIGNED_INT_WIDTH               int32_t
+#define PORT_TICS_PER_MS                    1000
+#define SCHEDULER_WAKEUP()
+#define SCHEDULER_ENABLE_INTERRUPT()
+
+//===== IEEE802154E timing
+// time-slot related
+#define PORT_TsSlotDuration                 15000
+
+#define PORT_maxTxDataPrepare               2014
+#define PORT_maxRxAckPrepare                900
+#define PORT_maxRxDataPrepare               976
+#define PORT_maxTxAckPrepare                900
+// radio speed related
+#define PORT_delayTx                        549
+#define PORT_delayRx                        0
+
+//===== adaptive_sync accuracy
+
+#define SYNC_ACCURACY                       2     // ticks
+
+//=========================== typedef  ========================================
+
+//=========================== variables =======================================
+
+static const uint8_t rreg_uriquery[]        = "h=ucb";
+static const uint8_t infoBoardname[]        = "riot-os";
+static const uint8_t infouCName[]           = "various";
+static const uint8_t infoRadioName[]        = "various";
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+//=========================== private =========================================
+
+#endif
diff --git a/bsp/boards/riot-adaption/board_ow.c b/bsp/boards/riot-adaption/board_ow.c
new file mode 100644
index 0000000..6c79b33
--- /dev/null
+++ b/bsp/boards/riot-adaption/board_ow.c
@@ -0,0 +1,22 @@
+#include "board_ow.h"
+#include "radiotimer.h"
+#include "radio.h"
+#include "debugpins.h"
+
+#define ENABLE_DEBUG (0)
+#include "debug.h"
+
+void board_init_ow(void)
+{
+    radio_init();
+    radiotimer_init();
+    debugpins_init();
+}
+
+void board_sleep(void)
+{
+}
+
+void board_reset(void)
+{
+}
\ No newline at end of file
diff --git a/bsp/boards/riot-adaption/debugpins.c b/bsp/boards/riot-adaption/debugpins.c
new file mode 100644
index 0000000..06c7c2e
--- /dev/null
+++ b/bsp/boards/riot-adaption/debugpins.c
@@ -0,0 +1,27 @@
+#include "debugpins.h"
+
+void debugpins_init(void) {}
+
+void debugpins_frame_toggle(void) {}
+void debugpins_frame_clr(void) {}
+void debugpins_frame_set(void) {}
+
+void debugpins_slot_toggle(void) {}
+void debugpins_slot_clr(void) {}
+void debugpins_slot_set(void) {}
+
+void debugpins_fsm_toggle(void) {}
+void debugpins_fsm_clr(void) {}
+void debugpins_fsm_set(void) {}
+
+void debugpins_task_toggle(void) {}
+void debugpins_task_clr(void) {}
+void debugpins_task_set(void) {}
+
+void debugpins_isr_toggle(void) {}
+void debugpins_isr_clr(void) {}
+void debugpins_isr_set(void) {}
+
+void debugpins_radio_toggle(void) {}
+void debugpins_radio_clr(void) {}
+void debugpins_radio_set(void) {}
\ No newline at end of file
diff --git a/bsp/boards/riot-adaption/eui64.c b/bsp/boards/riot-adaption/eui64.c
new file mode 100644
index 0000000..da9da6d
--- /dev/null
+++ b/bsp/boards/riot-adaption/eui64.c
@@ -0,0 +1,25 @@
+#include "eui64.h"
+
+//=========================== defines =========================================
+// stm32f103rey, 96-bit unique ID address
+#define UNIQUE_ID_BASE_ADDRESS          0x1FFFF7E8
+
+//=========================== variables =======================================
+
+const uint8_t const *uid = (const uint8_t *const) UNIQUE_ID_BASE_ADDRESS;
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+void eui64_get(uint8_t* addressToWrite)
+{
+  addressToWrite[0] = uid[0];
+  addressToWrite[1] = uid[1];
+  addressToWrite[2] = uid[2];
+  addressToWrite[3] = uid[3];
+  addressToWrite[4] = uid[4];
+  addressToWrite[5] = uid[5];
+  addressToWrite[6] = uid[6];
+  addressToWrite[7] = uid[7];
+}
\ No newline at end of file
diff --git a/bsp/boards/riot-adaption/leds_ow.c b/bsp/boards/riot-adaption/leds_ow.c
new file mode 100644
index 0000000..0c15981
--- /dev/null
+++ b/bsp/boards/riot-adaption/leds_ow.c
@@ -0,0 +1,111 @@
+#include "board.h"
+#include "leds.h"
+
+void _delay(void);
+
+void leds_init_ow(void)
+{
+}
+
+/* red */
+void leds_error_on(void)
+{
+  LED_RED_ON;
+}
+
+void leds_error_off(void)
+{
+  LED_RED_OFF;
+}
+void leds_error_toggle(void)
+{
+  LED_RED_TOGGLE;
+}
+uint8_t leds_error_isOn(void)
+{
+  return true;
+}
+void leds_error_blink(void) {}
+
+/* green */
+void leds_sync_on(void)
+{
+  LED_GREEN_ON;
+}
+void leds_sync_off(void)
+{
+  LED_GREEN_OFF;
+}
+void leds_sync_toggle(void)
+{
+  LED_GREEN_TOGGLE;
+}
+uint8_t leds_sync_isOn(void)
+{
+  return true;
+}
+
+/* orange */
+void leds_radio_on(void)
+{
+  LED_ORANGE_ON;
+}
+void leds_radio_off(void)
+{
+  LED_ORANGE_OFF;
+}
+void leds_radio_toggle(void)
+{
+  LED_ORANGE_TOGGLE;
+}
+uint8_t leds_radio_isOn(void)
+{
+  return true;
+}
+
+/* yellow */
+void leds_debug_on(void) {}
+void leds_debug_off(void) {}
+void leds_debug_toggle(void) {}
+uint8_t leds_debug_isOn(void) {
+    return 0;
+}
+
+void leds_all_on(void)
+{
+  leds_error_on();
+  leds_sync_on();
+  leds_radio_on();
+}
+void leds_all_off(void)
+{
+  leds_error_off();
+  leds_sync_off();
+  leds_radio_off();
+}
+void leds_all_toggle(void)
+{
+  leds_error_toggle();
+  leds_sync_toggle();
+  leds_radio_toggle();
+}
+
+void leds_circular_shift(void)
+{
+  leds_error_toggle();
+  _delay();
+  leds_sync_toggle();
+  _delay();
+  leds_radio_toggle();
+  _delay();
+}
+
+void leds_increment(void) {}
+
+//=========================== private =========================================
+
+void _delay(void)
+{
+  uint32_t i;
+  for(i=0; i<0xfffff; i++);
+}
diff --git a/bsp/boards/riot-adaption/radio.c b/bsp/boards/riot-adaption/radio.c
new file mode 100644
index 0000000..cb28da1
--- /dev/null
+++ b/bsp/boards/riot-adaption/radio.c
@@ -0,0 +1,259 @@
+#include "board_ow.h"
+#include "radio.h"
+#include "board.h"
+#include "at86rf231.h"
+#include "at86rf231_spi.h"
+#include "radiotimer.h"
+#include "debugpins.h"
+#include "leds.h"
+#include "periph_conf.h"
+
+#define ENABLE_DEBUG (0)
+#include "debug.h"
+
+
+//=========================== defines =========================================
+
+//=========================== variables =======================================
+
+typedef struct {
+   radiotimer_capture_cbt    startFrame_cb;
+   radiotimer_capture_cbt    endFrame_cb;
+   radio_state_t             state;
+} radio_vars_t;
+
+radio_vars_t radio_vars;
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+//===== admin
+
+void radio_init(void) {
+   DEBUG("%s\n", __PRETTY_FUNCTION__);
+   at86rf231_initialize(&at86rf231_netdev);
+   at86rf231_set_monitor(1);
+}
+
+void radio_setOverflowCb(radiotimer_compare_cbt cb) {
+   radiotimer_setOverflowCb(cb);
+}
+
+void radio_setCompareCb(radiotimer_compare_cbt cb) {
+   radiotimer_setCompareCb(cb);
+}
+
+void radio_setStartFrameCb(radiotimer_capture_cbt cb) {
+   radio_vars.startFrame_cb  = cb;
+}
+
+void radio_setEndFrameCb(radiotimer_capture_cbt cb) {
+   radio_vars.endFrame_cb    = cb;
+}
+
+//===== reset
+
+void radio_reset(void) {
+   at86rf231_off();
+   at86rf231_on();
+}
+
+//===== timer
+
+void radio_startTimer(PORT_TIMER_WIDTH period) {
+   radiotimer_start(period);
+}
+
+PORT_TIMER_WIDTH radio_getTimerValue(void) {
+   return radiotimer_getValue();
+}
+
+void radio_setTimerPeriod(PORT_TIMER_WIDTH period) {
+   radiotimer_setPeriod(period);
+}
+
+PORT_TIMER_WIDTH radio_getTimerPeriod(void) {
+   return radiotimer_getPeriod();
+}
+
+//===== RF admin
+
+void radio_setFrequency(uint8_t frequency) {
+   // change state
+   radio_vars.state = RADIOSTATE_SETTING_FREQUENCY;
+
+   // configure the radio to the right frequecy
+   at86rf231_set_channel(frequency);
+
+   // change state
+   radio_vars.state = RADIOSTATE_FREQUENCY_SET;
+}
+
+void radio_rfOn(void) {
+   at86rf231_on();
+}
+
+void radio_rfOff(void) {
+   leds_radio_off();
+}
+
+//===== TX
+
+void radio_loadPacket(uint8_t* packet, uint8_t len) {
+   DEBUG("rf load\n");
+   // change state
+   radio_vars.state = RADIOSTATE_LOADING_PACKET;
+
+   // load packet in TXFIFO
+   at86rf231_write_fifo(packet, len);
+
+   // change state
+   radio_vars.state = RADIOSTATE_PACKET_LOADED;
+}
+
+void radio_txEnable(void) {
+   // change state
+   radio_vars.state = RADIOSTATE_ENABLING_TX;
+   DEBUG("rf tx en\n");
+   leds_radio_on();
+
+   /* Go to state PLL_ON */
+    at86rf231_reg_write(AT86RF231_REG__TRX_STATE, AT86RF231_TRX_STATE__PLL_ON);
+
+    /* wait until it is on PLL_ON state */
+    do {
+        int max_wait = 100;
+        if (!--max_wait) {
+            DEBUG("at86rf231 : ERROR : could not enter PLL_ON mode\n");
+            break;
+        }
+    } while ((at86rf231_get_status() & AT86RF231_TRX_STATUS_MASK__TRX_STATUS)
+             != AT86RF231_TRX_STATUS__PLL_ON);
+
+    /* change into TX_ARET_ON state */
+    at86rf231_reg_write(AT86RF231_REG__TRX_STATE, AT86RF231_TRX_STATE__TX_ARET_ON);
+
+    do {
+        int max_wait = 100;
+        if (!--max_wait) {
+            DEBUG("at86rf231 : ERROR : could not enter TX_ARET_ON mode\n");
+            break;
+        }
+    } while (at86rf231_get_status() != AT86RF231_TRX_STATUS__TX_ARET_ON);
+
+   // change state
+   radio_vars.state = RADIOSTATE_TX_ENABLED;
+}
+
+void radio_txNow(void) {
+   PORT_TIMER_WIDTH val;
+   // change state
+   radio_vars.state = RADIOSTATE_TRANSMITTING;
+   leds_radio_toggle();
+
+   at86rf231_transmit_tx_buf(&at86rf231_netdev);
+
+   leds_radio_toggle();
+   // The AT86RF231 does not generate an interrupt when the radio transmits the
+   // SFD, which messes up the MAC state machine. The danger is that, if we leave
+   // this funtion like this, any radio watchdog timer will expire.
+   // Instead, we cheat an mimick a start of frame event by calling
+   // ieee154e_startOfFrame from here. This also means that software can never catch
+   // a radio glitch by which #radio_txEnable would not be followed by a packet being
+   // transmitted (I've never seen that).
+   if (radio_vars.startFrame_cb!=NULL) {
+      // call the callback
+      val=radiotimer_getCapturedTime();
+      radio_vars.startFrame_cb(val);
+   }
+   DEBUG("SENT");
+}
+
+//===== RX
+
+void radio_rxEnable(void) {
+   // change state
+   radio_vars.state = RADIOSTATE_ENABLING_RX;
+
+   // put radio in reception mode
+   // radio_spiWriteReg(RG_TRX_STATE, CMD_RX_ON);
+
+   at86rf231_switch_to_rx();
+
+   leds_radio_on();
+
+   // change state
+   radio_vars.state = RADIOSTATE_LISTENING;
+}
+
+void radio_rxNow(void) {
+   // nothing to do
+
+}
+
+void radio_getReceivedFrame(uint8_t* pBufRead,
+                            uint8_t* pLenRead,
+                            uint8_t  maxBufLen,
+                             int8_t* pRssi,
+                            uint8_t* pLqi,
+                               bool* pCrc) {
+   uint8_t temp_reg_value;
+
+   //===== crc
+   temp_reg_value  = at86rf231_reg_read(AT86RF231_REG__PHY_RSSI);
+   *pCrc           = (temp_reg_value & 0x80)>>7;  // msb is whether packet passed CRC
+   *pRssi          = (temp_reg_value & 0x0f);
+
+
+   // //===== packet
+   at86rf231_read_fifo(pLenRead, 1);
+   at86rf231_read_fifo(pBufRead, *pLenRead);
+   *pLqi = pBufRead[(*pLenRead)-1];
+}
+
+//=========================== private =========================================
+
+//=========================== callbacks =======================================
+
+//=========================== interrupt handlers ==============================
+
+void at86rf231_rx_irq(void) {
+   PORT_TIMER_WIDTH capturedTime;
+   uint8_t  irq_status;
+
+   // capture the time
+   capturedTime = radiotimer_getCapturedTime();
+
+   // reading IRQ_STATUS causes radio's IRQ pin to go low
+   irq_status = at86rf231_reg_read(AT86RF231_REG__IRQ_STATUS);
+
+   // start of frame event
+   if (irq_status & AT86RF231_IRQ_STATUS_MASK__RX_START) {
+       DEBUG("Start of frame.\n");
+      // change state
+      radio_vars.state = RADIOSTATE_RECEIVING;
+      if (radio_vars.startFrame_cb!=NULL) {
+         // call the callback
+         radio_vars.startFrame_cb(capturedTime);
+         // kick the OS
+         return;
+      } else {
+         while(1);
+      }
+   }
+   // end of frame event
+   if (irq_status & AT86RF231_IRQ_STATUS_MASK__TRX_END) {
+       DEBUG("End of Frame.\n");
+      // change state
+      radio_vars.state = RADIOSTATE_TXRX_DONE;
+      if (radio_vars.endFrame_cb!=NULL) {
+         // call the callback
+         radio_vars.endFrame_cb(capturedTime);
+         // kick the OS
+         return;
+      } else {
+         while(1);
+      }
+   }
+}
diff --git a/bsp/boards/riot-adaption/radiotimer.c b/bsp/boards/riot-adaption/radiotimer.c
new file mode 100644
index 0000000..47fa2d2
--- /dev/null
+++ b/bsp/boards/riot-adaption/radiotimer.c
@@ -0,0 +1,159 @@
+/**
+\brief openmoteSTM32 definition of the "radiotimer" bsp module.
+On openmoteSTM32, we use RTC for the radiotimer module.
+\author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
+\author Chang Tengfei <tengfei.chang@gmail.com>,  July 2012.
+*/
+
+#include "stdint.h"
+
+#include "periph/timer.h"
+#include "hwtimer.h"
+
+#include "leds.h"
+#include "radiotimer.h"
+#include "board_info.h"
+
+#include "riot.h"
+
+#define ENABLE_DEBUG (0)
+#include "debug.h"
+
+
+//=========================== variables =======================================
+
+enum  radiotimer_irqstatus_enum{
+    RADIOTIMER_NONE     = 0x00, //alarm interrupt default status
+    RADIOTIMER_OVERFLOW = 0x01, //alarm interrupt caused by overflow
+    RADIOTIMER_COMPARE  = 0x02, //alarm interrupt caused by compare
+};
+
+typedef struct {
+   radiotimer_compare_cbt    overflow_cb;
+   radiotimer_compare_cbt    compare_cb;
+   uint8_t                   overflowORcompare;//indicate RTC alarm interrupt status
+   uint16_t                  currentSlotPeriod;
+} radiotimer_vars_t;
+
+volatile radiotimer_vars_t radiotimer_vars;
+uint16_t current_period;
+
+//=========================== prototypes ======================================
+extern int timer_set_relative(tim_t, int channel, unsigned int rel_value);
+//=========================== public ==========================================
+
+//===== admin
+
+void radiotimer_init(void) {
+   // clear local variables
+   memset((void*)&radiotimer_vars,0,sizeof(radiotimer_vars_t));
+   current_period = 0;
+}
+
+void radiotimer_setOverflowCb(radiotimer_compare_cbt cb) {
+   radiotimer_vars.overflow_cb    = cb;
+}
+
+void radiotimer_setCompareCb(radiotimer_compare_cbt cb) {
+   radiotimer_vars.compare_cb     = cb;
+}
+
+void radiotimer_setStartFrameCb(radiotimer_capture_cbt cb) {
+   while(1);
+}
+
+void radiotimer_setEndFrameCb(radiotimer_capture_cbt cb) {
+   while(1);
+}
+
+void radiotimer_start(PORT_RADIOTIMER_WIDTH period) {
+    DEBUG("%s\n", __PRETTY_FUNCTION__);
+    // timer_init(OWSN_TIMER, 1, &radiotimer_isr);
+    timer_set(OWSN_TIMER, 1, ((unsigned int)HWTIMER_TICKS(period)*10));
+    current_period = period;
+   radiotimer_vars.currentSlotPeriod = period;
+   radiotimer_vars.overflowORcompare = RADIOTIMER_OVERFLOW;
+}
+
+//===== direct access
+
+PORT_RADIOTIMER_WIDTH radiotimer_getValue(void) {
+    return (PORT_RADIOTIMER_WIDTH)(HWTIMER_TICKS_TO_US(timer_read(OWSN_TIMER)));
+}
+
+void radiotimer_setPeriod(PORT_RADIOTIMER_WIDTH period) {
+    DEBUG("%s\n", __PRETTY_FUNCTION__);
+    timer_set(OWSN_TIMER, 1, ((unsigned int)HWTIMER_TICKS(period)*10));
+    current_period = period;
+    radiotimer_vars.currentSlotPeriod = period;
+
+    //set radiotimer irpstatus
+    radiotimer_vars.overflowORcompare = RADIOTIMER_OVERFLOW;
+}
+
+PORT_RADIOTIMER_WIDTH radiotimer_getPeriod(void) {
+    return current_period;
+}
+
+//===== compare
+
+void radiotimer_schedule(PORT_RADIOTIMER_WIDTH offset) {
+    DEBUG("%s\n", __PRETTY_FUNCTION__);
+    timer_irq_disable(OWSN_TIMER);
+    timer_set(OWSN_TIMER, 1, HWTIMER_TICKS(offset)*10);
+    timer_irq_enable(OWSN_TIMER);
+    //set radiotimer irpstatus
+    radiotimer_vars.overflowORcompare = RADIOTIMER_COMPARE;
+}
+
+void radiotimer_cancel(void) {
+    DEBUG("%s\n", __PRETTY_FUNCTION__);
+    timer_irq_disable(OWSN_TIMER);
+    // timer_clear(OWSN_TIMER, 1);
+    timer_set(OWSN_TIMER, 1, HWTIMER_TICKS(current_period)*10);
+    timer_irq_enable(OWSN_TIMER);
+
+    //set radiotimer irpstatus
+    radiotimer_vars.overflowORcompare = RADIOTIMER_OVERFLOW;
+}
+
+//===== capture
+
+inline PORT_RADIOTIMER_WIDTH radiotimer_getCapturedTime(void) {
+    return (PORT_RADIOTIMER_WIDTH)(timer_read(OWSN_TIMER));
+}
+
+//=========================== private =========================================
+
+//=========================== interrupt handlers ==============================
+void radiotimer_isr(void) {
+    uint8_t taiv_temp = radiotimer_vars.overflowORcompare;
+    switch (taiv_temp) {
+        case RADIOTIMER_COMPARE:
+            DEBUG("%s cmp\n", __PRETTY_FUNCTION__);
+            if (radiotimer_vars.compare_cb!=NULL) {
+                radiotimer_vars.compare_cb();
+                // kick the OS
+                // return KICK_SCHEDULER;
+            }
+            break;
+        case RADIOTIMER_OVERFLOW: // timer overflows
+            DEBUG("%s of\n", __PRETTY_FUNCTION__);
+            if (radiotimer_vars.overflow_cb!=NULL) {
+                //Wait until last write operation on RTC registers has finished
+                timer_set(OWSN_TIMER, 1, HWTIMER_TICKS(current_period)*10);
+                // call the callback
+                radiotimer_vars.overflow_cb();
+                DEBUG("returned...\n");
+                // kick the OS
+                // return KICK_SCHEDULER;
+            }
+            break;
+      case RADIOTIMER_NONE:                     // this should not happen
+            DEBUG("%s none\n", __PRETTY_FUNCTION__);
+      default:
+            DEBUG("%s default\n", __PRETTY_FUNCTION__);
+            // while(1);                               // this should not happen
+    }
+    // return DO_NOT_KICK_SCHEDULER;
+}
\ No newline at end of file
diff --git a/bsp/boards/riot-adaption/riot.h b/bsp/boards/riot-adaption/riot.h
new file mode 100644
index 0000000..982241c
--- /dev/null
+++ b/bsp/boards/riot-adaption/riot.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2014 Freie Universit√§t Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @{
+ *
+ * @file
+ * @brief           RIOT specific definitions for OpenWSN
+ *
+ * @author          Thomas Eichinger <thomas.eichinger@fu-berlin.de>
+ */
+
+#ifndef __RIOT_H
+#define __RIOT_H
+
+#include "thread.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief The peripheral timer to use with OpenWSN
+ */
+#define OWSN_TIMER  TIMER_1
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __RIOT_H */
+/** @} */
\ No newline at end of file
diff --git a/bsp/boards/riot-adaption/uart_ow.c b/bsp/boards/riot-adaption/uart_ow.c
new file mode 100644
index 0000000..bd62ee6
--- /dev/null
+++ b/bsp/boards/riot-adaption/uart_ow.c
@@ -0,0 +1,96 @@
+#include "uart.h"
+#include "leds.h"
+#include "periph/uart.h"
+
+//=========================== defines =========================================
+
+//=========================== variables =======================================
+
+typedef struct {
+   uart_tx_cbt txCb;
+   uart_rx_cbt rxCb;
+   uint8_t     startOrend;
+   uint8_t     flagByte;
+} uart_vars_t;
+
+volatile uart_vars_t uart_vars;
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+void uart_init_ow(void)
+{
+  // reset local variables
+  memset((void*)&uart_vars,0,sizeof(uart_vars_t));
+
+  //when this value is 0, we are send the first data
+  uart_vars.startOrend = 0;
+  //flag byte for start byte and end byte
+  uart_vars.flagByte = 0x7E;
+}
+
+void uart_setCallbacks(uart_tx_cbt txCb, uart_rx_cbt rxCb)
+{
+  uart_vars.txCb = txCb;
+  uart_vars.rxCb = rxCb;
+}
+
+void uart_enableInterrupts(void)
+{
+  // USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
+}
+
+void uart_disableInterrupts(void)
+{
+  // USART_ITConfig(USART1, USART_IT_TXE, DISABLE);
+  // USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);
+}
+
+void uart_clearRxInterrupts(void)
+{
+  // USART_ClearFlag(USART1, USART_FLAG_RXNE);
+}
+
+void uart_clearTxInterrupts(void)
+{
+  // USART_ClearFlag(USART1, USART_FLAG_TXE);
+}
+
+void uart_writeByte(uint8_t byteToWrite)
+{
+  // USART_SendData(USART1, byteToWrite);
+  // while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
+
+  // //start or end byte?
+  // if(byteToWrite == uart_vars.flagByte) {
+  //   uart_vars.startOrend = (uart_vars.startOrend == 0)?1:0;
+  //   //start byte
+  //   if(uart_vars.startOrend == 1) {
+  //     USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
+  //   } else {
+  //     USART_ITConfig(USART1, USART_IT_TXE, DISABLE);
+  //   }
+  // }
+}
+
+uint8_t uart_readByte(void)
+{
+  uint16_t temp = 0;
+  // temp = USART_ReceiveData(USART1);
+  return (uint8_t)temp;
+}
+
+//=========================== interrupt handlers ==============================
+
+kick_scheduler_t uart_tx_isr(void)
+{
+  uart_vars.txCb();
+  return DO_NOT_KICK_SCHEDULER;
+}
+
+kick_scheduler_t uart_rx_isr(void)
+{
+  uart_vars.rxCb();
+  return DO_NOT_KICK_SCHEDULER;
+}
\ No newline at end of file
-- 
2.4.5

